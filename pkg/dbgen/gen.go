package dbgen

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"runtime/debug"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"

	"gorm.io/gorm"
)

var tpl = `// Code generated by go-exp. DO NOT EDIT.

package dao

import (
	"context"
	"reflect"

	"{{.ModelPackage}}/internal/dao/model"

	"{{.ModelPackage}}/pkg/dbgen"
	"gorm.io/gorm"
	{{range .ImportPkgPaths}}{{.}} 
{{end}}
)

func ({{.S}} *{{.DaoName}}) DB() *gorm.DB {
	return {{.S}}.{{.DaoName}}Do.DO.UnderlyingDB()
}

func ({{.S}} *{{.DaoName}}) Get(ctx context.Context, id {{.PKType}}, withDeleted ...bool) (result *model.{{.ModelName}}, err error) {
	err = {{.S}}.DB().WithContext(ctx).Table(model.TableName{{.ModelName}}).
		Scopes(dbgen.WithDeletedList(withDeleted)).
		Where("{{ .PrimaryField }} = ?", id).
		First(&result).
		Error
	if err != nil {
		return nil, err
	}

	return result, nil
}

func ({{.S}} *{{.DaoName}}) GetList(ctx context.Context, id []{{.PKType}}, withDeleted ...bool) (list []*model.{{.ModelName}}, err error) {
	err = {{.S}}.DB().WithContext(ctx).Table(model.TableName{{.ModelName}}).
		Scopes(dbgen.WithDeletedList(withDeleted)).
		Where("{{ .PrimaryField }} IN ?", id).
		Find(&list).
		Error
	if err != nil {
		return nil, err
	}

	return list, nil
}

// List{{.ModelName}}Params represents the params to list models
type List{{.ModelName}}Params struct {
	dbgen.Pager

{{range $element := .ParamsKey}}
    {{$element}}
{{- end}}

	Deleted bool // optional
}

// List returns the specified models from database by params
func ({{.S}} *{{.DaoName}}) List(ctx context.Context, params *List{{.ModelName}}Params) (list []*model.{{.ModelName}}, total int64, err error) {
	tx := {{.S}}.DB().WithContext(ctx).Table(model.TableName{{.ModelName}}).
		Scopes(dbgen.WithDeleted(params.Deleted)).
		Scopes(dbgen.Paginate(params.Pager)).
	{{- range $element := .ParamsScopes}}
        {{$element}}
    {{- end}}
	{{ if .Desc }}
		Order("{{ .PrimaryField }} desc")
	{{ else }}
		Order("{{ .PrimaryField }} asc")
	{{ end }}

	total, err = dbgen.FindAndCountTransaction(tx, &list)
	if err != nil {
		return nil, 0, err
	}

	return list, total, nil
}

func ({{.S}} *{{.DaoName}}) Update(ctx context.Context, model *model.{{.ModelName}}, cols ...string) error {
	return {{.S}}.DB().WithContext(ctx).
		Model(model).
		Select(cols).
		Updates(model).
		Error
}

func ({{.S}} *{{.DaoName}}) DeleteByID(ctx context.Context, id {{.PKType}}) error {
	return {{.S}}.DB().WithContext(ctx).Table(model.TableName{{.ModelName}}).
		Delete(&model.{{.ModelName}}{}, id).Error
}

func ({{.S}} *{{.DaoName}}) Destroy(ctx context.Context, id {{.PKType}}) error {
	return {{.S}}.DB().WithContext(ctx).Table(model.TableName{{.ModelName}}).
		Unscoped().
		Delete(&model.{{.ModelName}}{}, id).Error
}

`

var customTpl = `package dao

import (
	"context"

	"{{.ModelPackage}}/internal/dao/model"
)

func ({{.S}} *{{.DaoName}}) Example(ctx context.Context) (result *model.{{.ModelName}}, err error) {
	// example code
	return {{.S}}.WithContext(ctx).First()
}

`

type DbParams struct {
	ModelPackage   string   // model package
	DaoName        string   // dao name
	ModelName      string   // model name
	S              string   // the first letter(lower case)of simple Name (receiver)
	PKType         string   // primary key type
	ParamsKey      []string // params key
	ParamsScopes   []string // params scopes
	ImportPkgPaths []string
	PrimaryField   string
	Desc           bool // params key sort
}

func BuildParamsKey(colGo, colGoType string, unique bool) string {
	if colGoType == "string" && !unique {
		return fmt.Sprintf("%s %s // optional, likely", colGo, colGoType)
	} else {
		return fmt.Sprintf("%s %s // optional", colGo, colGoType)
	}
}

func BuildCand(colGo, columnName, colGoType string, unique bool) string {
	if colGoType == `string` && !unique {
		return fmt.Sprintf(`Scopes(dbgen.Cond(!reflect.ValueOf(params.%s).IsZero(), "%s like ?", "%%"+params.%s+"%%")).`, colGo, columnName, colGo)
	} else {
		return fmt.Sprintf(`Scopes(dbgen.Cond(!reflect.ValueOf(params.%s).IsZero(), "%s = ?", params.%s)).`, colGo, columnName, colGo)
	}
}

func BuildNullable(colGo, columnName string) string {
	return fmt.Sprintf(`Scopes(dbgen.Nullable(params.%s != nil, "%s = ?", func() any { return *params.%s })).`, colGo, columnName, colGo)
}

func Build(params *DbParams, fileName string) error {
	// 创建一个 buffer 用于存储生成的代码
	var buf bytes.Buffer

	// 解析和执行模板
	tmpl, err := template.New("dao").Parse(tpl)
	if err != nil {
		return err
	}

	err = tmpl.Execute(&buf, params)
	if err != nil {
		return err
	}

	// 使用 go/format 包格式化代码
	formattedSource, err := imports.Process(fileName, buf.Bytes(), nil)
	if err != nil {
		return err
	}

	// 生成的代码
	file, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer func() {
		_ = file.Close()
	}()
	_, err = file.Write(formattedSource)
	if err != nil {
		return err
	}

	return nil
}

func BuildCustom(params *DbParams, fileName string) error {
	// 文件存在不生成
	if fileExists(fileName) {
		return nil
	}

	// 创建一个 buffer 用于存储生成的代码
	var buf bytes.Buffer

	// 解析和执行模板
	tmpl, err := template.New("dao-custom").Parse(customTpl)
	if err != nil {
		return err
	}

	err = tmpl.Execute(&buf, params)
	if err != nil {
		return err
	}

	// 使用 go/format 包格式化代码
	formattedSource, err := imports.Process(fileName, buf.Bytes(), nil)
	if err != nil {
		return err
	}

	// 生成的代码
	file, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer func() {
		_ = file.Close()
	}()
	_, err = file.Write(formattedSource)
	if err != nil {
		return err
	}

	return nil
}

func Params(table, modelStructName string, columnTypes []gorm.ColumnType, dataMap map[string]func(gorm.ColumnType) (dataType string)) (*DbParams, error) {
	goModel, err := getModuleName()
	if err != nil {
		return nil, err
	}

	p := &DbParams{
		ModelPackage:   goModel,
		DaoName:        unaptialize(modelStructName),
		ModelName:      modelStructName,
		S:              getPureName(modelStructName),
		PKType:         "",
		ParamsKey:      make([]string, 0),
		ParamsScopes:   make([]string, 0),
		ImportPkgPaths: nil,
		PrimaryField:   "id",
		Desc:           true,
	}

	for _, columnType := range columnTypes {
		columnName := columnType.Name()
		colGo := SnakeToPascalCase(columnName)
		colGoType := dataMap[strings.ToLower(columnType.DatabaseTypeName())](columnType)
		unique := false

		if isPrimaryKey, ok := columnType.PrimaryKey(); ok {
			if isPrimaryKey {
				p.PrimaryField = columnName
				p.PKType = colGoType

				if comment, ok := columnType.Comment(); ok {
					if strings.Contains(comment, "asc") {
						p.Desc = false
					} else if strings.Contains(comment, "desc") {
						p.Desc = true
					}
				}

				continue
			}
		}

		if flag, ok := columnType.Unique(); ok {
			unique = flag
		}

		if columnName == "version" || columnName == "created_at" || columnName == "updated_at" || columnName == "deleted_at" {
			continue
		}
		p.ParamsKey = append(p.ParamsKey, BuildParamsKey(colGo, colGoType, unique))
		if strings.HasPrefix(colGoType, "*") {
			p.ParamsScopes = append(p.ParamsScopes, BuildNullable(colGo, columnName))
		} else {
			p.ParamsScopes = append(p.ParamsScopes, BuildCand(colGo, columnName, colGoType, unique))
		}
	}

	if p.PKType == "" {
		err = errors.New(fmt.Sprintf("table %s no primary key", table))
		return nil, err
	}

	return p, nil
}

func getModuleName() (string, error) {
	info, ok := debug.ReadBuildInfo()
	if !ok {
		return "", fmt.Errorf("failed to read build info")
	}
	return info.Main.Path, nil
}

func unaptialize(s string) string {
	if s == "" {
		return ""
	}

	return strings.ToLower(s[:1]) + s[1:]
}

func SnakeToPascalCase(s string) string {
	if s == "" {
		return ""
	}

	words := strings.Split(s, "_") // 将字符串按 "_" 分割成单词切片
	result := ""
	for _, word := range words {
		if len(word) > 0 {
			// 将每个单词的首字母转换为大写，并将剩余部分与首字母连接起来
			result += strings.ToUpper(string(word[0])) + word[1:]
		}
	}
	return result
}

func delPointerSym(name string) string {
	return strings.TrimLeft(name, "*")
}

// the first letter(lower case)of simple Name (receiver)
func getPureName(s string) string {
	return string(strings.ToLower(delPointerSym(s))[0])
}

func fileExists(filename string) bool {
	// 使用 os.Stat 获取文件信息
	_, err := os.Stat(filename)
	// 如果错误为 nil，表示文件存在
	if err == nil {
		return true
	}
	// 如果错误是 os.ErrNotExist，表示文件不存在
	if os.IsNotExist(err) {
		return false
	}
	// 其他错误处理
	return false
}
